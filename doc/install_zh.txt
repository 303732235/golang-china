<!-- Installing Go -->

Introduction
----

Go is an open source project, distributed under a BSD-style license. This document explains how to check out the sources, build them on your own machine, and run them.

There are two distinct ways to experiment with Go. This document focuses on the gc Go compiler and tools (6g, 8g etc.). For information on how to use gccgo, a more traditional compiler using the GCC back end, see Setting up and using gccgo.

Environment variables
----

The Go compilation environment depends on three environment variables that you should set in your .bashrc or equivalent, plus one optional variable:

$GOROOT
The root of the Go tree. Typically this is $HOME/go but it can be any directory.
$GOOS and $GOARCH
The name of the target operating system and compilation architecture. Choices for $GOOS are linux, freebsd, darwin (Mac OS X 10.5 or 10.6), and nacl (Native Client, an incomplete port). Choices for $GOARCH are amd64 (64-bit x86, the most mature port), 386 (32-bit x86), and arm (32-bit ARM, an incomplete port). The valid combinations of $GOOS and $GOARCH are:
$GOOS	$GOARCH
darwin	386
darwin	amd64
freebsd	386
freebsd	amd64
linux	386
linux	amd64
linux	arm
nacl	386
$GOBIN (optional)
The location where binaries will be installed. The default is $HOME/bin. After installing, you will want to arrange to add this directory to your $PATH, so you can use the tools.
Note that $GOARCH and $GOOS identify the target environment, not the environment you are running on. In effect, you are always cross-compiling.

Set these variables in your .bashrc. For example:

export GOROOT=$HOME/go
export GOARCH=amd64
export GOOS=linux
Double-check them by listing your environment.

$ env | grep '^GO'

Ports
----

Go compilers support two operating systems (Linux, Mac OS X) and three instruction sets. The versions for Linux and Mac are equally capable except that the ARM port does not run on OS X (yet).

There are important differences in the quality of the compilers for the different architectures.

amd64 (a.k.a. x86-64); 6g,6l,6c,6a
The most mature implementation. The compiler has an effective optimizer (registerizer) and generates good code (although gccgo can do noticeably better sometimes).
386 (a.k.a. x86 or x86-32); 8g,8l,8c,8a
Comparable to the amd64 port. Not as well soaked but should be nearly as solid.
arm (a.k.a. ARM); 5g,5l,5c,5a
It's got a couple of outstanding bugs but is improving. Tested against QEMU and an android phone.
Except for things like low-level operating system interface code, the runtime support is the same in all ports and includes a mark-and-sweep garbage collector (a fancier one is in the works), efficient array and string slicing, support for segmented stacks, and a strong goroutine implementation.

See the separate gccgo document for details about that compiler and environment.

Fetch the repository
----

If you do not have Mercurial installed (you do not have an hg command), this command:

$ sudo easy_install mercurial
works on most systems. (On Ubuntu, you might try apt-get install python-setuptools python-dev first.) If that fails, visit the Mercurial Download page.

Make sure the $GOROOT directory does not exist or is empty. Then check out the repository:

$ hg clone -r release https://go.googlecode.com/hg/ $GOROOT

Install Go
----

The Go tool chain is written in C. To build it, you need to have GCC, the standard C libraries, the parser generator Bison, make and the text editor ed installed. On OS X, they can be installed as part of Xcode. On Linux,

$ sudo apt-get install bison gcc libc6-dev ed make
(or the equivalent on your Linux distribution).

To build the Go distribution, run

$ cd $GOROOT/src
$ make all
If make all goes well, it will finish by printing

--- cd ../test
N known bugs; 0 unexpected bugs
where N is a number that varies from release to release.

Writing programs
----

Given a file file.go, compile it using

$ 6g file.go
6g is the Go compiler for amd64; it will write the output in file.6. The ‘6’ identifies files for the amd64 architecture. The identifier letters for 386 and arm are ‘8’ and ‘5’. That is, if you were compiling for 386, you would use 8g and the output would be named file.8.

To link the file, use

$ 6l file.6
and to run it

$ ./6.out
A complete example:

$ cat >hello.go <<EOF
package main

import "fmt"

func main() {
	fmt.Printf("hello, world\n")
}
EOF
$ 6g hello.go
$ 6l hello.6
$ ./6.out
hello, world
$
There is no need to list hello.6's package dependencies (in this case, package fmt) on the 6l command line. The linker learns about them by reading hello.6.

To build more complicated programs, you will probably want to use a Makefile. There are examples in places like $GOROOT/src/cmd/godoc/Makefile and $GOROOT/src/pkg/*/Makefile. The document about contributing to the Go project gives more detail about the process of building and testing Go programs.

Keeping up with releases
----

New releases are announced on the Go Nuts mailing list. To update an existing tree to the latest release, you can run:

$ cd $GOROOT/src
$ hg pull
$ hg update release
$ make all

Community resources
----

For real-time help, there may be users or developers on #go-nuts on the Freenode IRC server.

The official mailing list for discussion of the Go language is Go Nuts.

Bugs can be reported using the Go issue tracker.

For those who wish to keep up with development, there is another mailing list, golang-checkins, that receives a message summarizing each checkin to the Go repository.
<!-- Go编程语言简介 -->

译者
----

	原文：<a href='http://golang.org/go_tutorial.html'>http://golang.org/go_tutorial.html</a>
	翻译：<a href='http://chaishushan.blog.163.com'>柴树杉</a> <a href='mailto:chaishushan@gmail.com'>(chaishushan@gmail.com)</a>
	翻译：<a href='http://www.wifihack.net/'>Bian Jiang</a> <a href='mailto:borderj@gmail.com'>(borderj@gmail.com)</a>

Introduction 简介
----

This document is a tutorial introduction to the basics of the Go programming
language, intended for programmers familiar with C or C++. It is not a comprehensive
guide to the language; at the moment the document closest to that is the
<a href='/doc/go_spec.html'>language specification</a>.
After you've read this tutorial, you might want to look at
<a href='/doc/effective_go.html'>Effective Go</a>,
which digs deeper into how the language is used.
Also, slides from a 3-day course about Go are available:
<a href='/doc/GoCourseDay1.pdf'>Day 1</a>,
<a href='/doc/GoCourseDay2.pdf'>Day 2</a>,
<a href='/doc/GoCourseDay3.pdf'>Day 3</a>.

本文是关于Go编程语言的基础教程，主要面向有C/C++基础的读者。它并不是一个语言的完整指南，关于
Go的具体细节请参考 <a href='/doc/go_spec.html'>语言规范</a> 一文。在读完这个入门教程后，
深入的华可以继续看 <a href='/doc/effective_go.html'>Effective Go</a> ，这个文档
将涉及到Go语言的更多特性。此外，还有一个《Go语言三日教程》系列讲座：
<a href='/doc/GoCourseDay1.pdf'>第一日</a>,
<a href='/doc/GoCourseDay2.pdf'>第二日</a>,
<a href='/doc/GoCourseDay3.pdf'>第三日</a>。 

The presentation here proceeds through a series of modest programs to illustrate
key features of the language.  All the programs work (at time of writing) and are
checked into the repository in the directory <a href='/doc/progs'>"/doc/progs/"</a>.

下面将通过一些小程序来演示go语言的一些关键特性。所有的演示程序都是可以运行的，程序的代码在安装目录的
<a href='/doc/progs'>"/doc/progs/"</a>子目录中。

Program snippets are annotated with the line number in the original file; for
cleanliness, blank lines remain blank.

文中的代码都会标出在源代码文件中对应的行号。同时为了清晰起见，我们忽略了源代码文件空白行的行号。

Hello, World 你好，世界
----

Let's start in the usual way:

让我们从经典的"Hello, World"程序开始：

--PROG progs/helloworld.go /package/ END

Every Go source file declares, using a "package" statement, which package it's part of.
It may also import other packages to use their facilities.
This program imports the package "fmt" to gain access to
our old, now capitalized and package-qualified, friend, "fmt.Printf".

每个Go源文件开头都有一个"package"声明语句，指明源文件所在的包。同时，我们也可以根据具体的需要
来选择导入（import语句）特定功能的包。在这个例子中，我们通过导入“fmt”包来使用我们熟悉的printf函数。
不过在Go语言中，Printf函数的是大写字母开头，并且以fmt包名作为前缀：fmt.Printf。

Functions are introduced with the "func" keyword.
The "main" package's "main" function is where the program starts running (after
any initialization).

关键字“func“用于定义函数。在所有初始化完成后，程序从main包中的main函数开始执行。

String constants can contain Unicode characters, encoded in UTF-8.
(In fact, Go source files are defined to be encoded in UTF-8.)

常量字符串可以包含Unicode字符，采用UTF-8编码。实际上，所有的Go语言源文件都采用UTF-8编码。

The comment convention is the same as in C++:

代码注释的方式和C++类似：

	/* ... */
	// ...

Later we'll have much more to say about printing.

稍后，我们还有很多的关于打印的话题。

Semicolons 分号
----

You might have noticed that our program has no semicolons.  In Go
code, the only place you typically see semicolons is separating the
clauses of "for" loops and the like; they are not necessary after
every statement.

比较细心的读者可能发现前面的代码中基本没有出现分号“;”。其实在go语言中，只有在分隔
for循环的初始化语句时才经常用到；但是代码段末尾的分号一般都是省略的。

In fact, what happens is that the formal language uses semicolons,
much as in C or Java, but they are inserted automatically
at the end of every line that looks like the end of a statement. You
don't need to type them yourself.

当然，你也可以像C或JAVA中那样使用分号。不过在大多数情况下，一个完整语句末尾的分号
都是有go编译器自动添加的——用户不需要输入每个分号。

For details about how this is done you can see the language
specification, but in practice all you need to know is that you
never need to put a semicolon at the end of a line.  (You can put
them in if you want to write multiple statements per line.) As an
extra help, you can also leave out a semicolon immediately before
a closing brace.

关于分号的详细描述，可以查看Go语言说明文档。不过在实际写代码时，只需要记得一行末尾的分号
可以省略就可以了（对于一行写多个语句的，可以用分号隔开）。还有一个额外的好处是：在退出
大括号包围的子区域时，分号也是可以省略的。

This approach makes for clean-looking, semicolon-free code.  The
one surprise is that it's important to put the opening
brace of a construct such as an "if" statement on the same line as
the "if"; if you don't, there are situations that may not compile
or may give the wrong result.  The language forces the brace style
to some extent.

在一些特殊情况下，甚至可以写出没有任何分号的代码。不过有一个重要的地方：对于"if"等
后面有大括弧的语句，需要将左大括弧放在"if"语句的同一行，如果不这样的话可能出现编译错误。
Go语言强制使用将开始大括弧放在同一行末尾的编码风格。

Compiling 编译
----

Go is a compiled language.  At the moment there are two compilers.
"Gccgo" is a Go compiler that uses the GCC back end.  There is also a
suite of compilers with different (and odd) names for each architecture:
"6g" for the 64-bit x86, "8g" for the 32-bit x86, and more.  These
compilers run significantly faster but generate less efficient code
than "gccgo".  At the time of writing (late 2009), they also have
a more robust run-time system although "gccgo" is catching up.

Go是一个编译型的语言。目前有两种编译器，其中"Gccgo"采用GCC作为编译后端。另外还有
根据处理器架构命名的编译器：针对64位x86结构为"6g"，针对32位x86结构的为"8g"等等。
这些go专用的编译器编译很快，但是产生的目标代码效率比gccgo稍差一点。目前（2009年底），
go专用的编译器的运行时系统比"gccgo"要相对健壮一点。

Here's how to compile and run our program.  With "6g", say,

下面看看如何编译并运行程序。先是用针对64位x86结构处理器的“6g”：

	$ 6g helloworld.go  # 编译; 输出 helloworld.6
	$ 6l helloworld.6   # 链接; 输出 6.out
	$ 6.out
	Hello, world; or Καλημέρα κόσμε; or こんにちは 世界
	$

With "gccgo" it looks a little more traditional.

如果是用gccgo编译，方法和传统的gcc编译方法类似：

	$ gccgo helloworld.go
	$ a.out
	Hello, world; or Καλημέρα κόσμε; or こんにちは 世界
	$

Echo
----

Next up, here's a version of the Unix utility "echo(1)":

下面的例子是Unix系统中"echo"命令的简单实现：

--PROG progs/echo.go /package/ END

This program is small but it's doing a number of new things.  In the last example,
we saw "func" introduce a function.  The keywords "var", "const", and "type"
(not used yet) also introduce declarations, as does "import".
Notice that we can group declarations of the same sort into
parenthesized lists, one item per line, as on lines 7-10 and 14-17.
But it's not necessary to do so; we could have said

程序虽然很小，但是包含了go语言的更多特性。在上一个的例子中，我们演示了如何用"func"关键字定义函数。
类似的关键字还有："var"、"const"和"type"等，它们可以用于定义变量、常量和类型等，用法和"import"一致。
我们可以小括弧声明一组类型相同的变量（如7－10和14－17行所示）。当然，也可以分开独立定义：

	const Space = " "
	const Newline = "\n"

This program imports the "&quot;os&quot;" package to access its "Stdout" variable, of type
"*os.File".  The "import" statement is actually a declaration: in its general form,
as used in our ``hello world'' program,
it names the identifier ("fmt")
that will be used to access members of the package imported from the file ("&quot;fmt&quot;"),
found in the current directory or in a standard location.
In this program, though, we've dropped the explicit name from the imports; by default,
packages are imported using the name defined by the imported package,
which by convention is of course the file name itself.  Our ``hello world'' program
could have said just "import &quot;fmt&quot;".

程序首先导入"&quot;os&quot;"包，因为后面要用到包中的一个"*os.File"类型的"Stdout"变量。
这里的"import"语句实际上是一个声明，和我们在“hello world“程序中所使用方法一样，包的名字标识符（fmt）
为前缀用于定位包中定位包中的成员，包可以是在当前目录或标准包目录。在导入包的时候一般会默认选用包本身的
名字（在必要的时候可以将导入的包重新命名）。在“hello world“程序中，我们只是简单的
"import &quot;fmt&quot;"。

You can specify your
own import names if you want but it's only necessary if you need to resolve
a naming conflict.

如果需要，你可以自己重新命名被import的包。但那不是必须的，只在处理包名字冲突的时候会用到。

Given "os.Stdout" we can use its "WriteString" method to print the string.

通过"os.Stdout"，我们可以用包中的"WriteString"方法来输出字符串。

Having imported the "flag" package, line 12 creates a global variable to hold
the value of echo's "-n" flag. The variable "omitNewline" has type "*bool", pointer
to "bool".

现在已经导入"flag"包，并且在12行创建了一个全局变量，用于保存echo的"-n"命令行选项。变量
"omitNewline"为一个只想bool变量的bool型指针。

In "main.main", we parse the arguments (line 20) and then create a local
string variable we will use to build the output.

在"main.main"中，我们首先解析命令行参数（20行），然后创建了一个局部字符串变量用于保存要输出的内容。

The declaration statement has the form

变量声明语法如下：

	var s string = "";

This is the "var" keyword, followed by the name of the variable, followed by
its type, followed by an equals sign and an initial value for the variable.

这里有一个"var"关键字，后面跟着变量名字和变量的数据类型，再后面可以用“＝”符号来进行赋初值。

Go tries to be terse, and this declaration could be shortened.  Since the
string constant is of type string, we don't have to tell the compiler that.
We could write

简洁是go的一个目标，变量的定义也有更简略的语法。go可以根据初始值来判断变量的类型，
没有必要显式写出数据类型。也可以这样定义变量：

	var s = "";

or we could go even shorter and write the idiom

还有更短的写法：

	s := "";

The ":=" operator is used a lot in Go to represent an initializing declaration.
There's one in the "for" clause on the next line:


操作符":="将在Go中声明同时进行初始化一个变量时会经常使用。下面的代码是在"for"中声明并
初始化变量：

--PROG  progs/echo.go /for/

The "flag" package has parsed the arguments and left the non-flag arguments
in a list that can be iterated over in the obvious way.

"flag"包会解析命令行参数，并将不是flag选项的参数保存到一个列表中。可以通过flag的参数列表
访问普通的命令行参数。

The Go "for" statement differs from that of C in a number of ways.  First,
it's the only looping construct; there is no "while" or "do".  Second,
there are no parentheses on the clause, but the braces on the body
are mandatory.  The same applies to the "if" and "switch" statements.
Later examples will show some other ways "for" can be written.

Go语言的"for"语句和C语言中有几个不同的地方：第一，for是Go中唯一的循环语句，Go中没有while或
do语句；第二，for的条件语句并不需要用小括号包起来，但是循环体却必须要花括弧，这个规则同样适用于
if和switch。后面我们会看到for的一些例子。

The body of the loop builds up the string "s" by appending (using "+=")
the flags and separating spaces. After the loop, if the "-n" flag is not
set, the program appends a newline. Finally, it writes the result.

在循环体中，通过"+="操作符向字符串"s"添加要命令行参数和空白。在循环结束后，根据命令行是否有"-n"选项，
判断末尾是否要添加换行符。最后输出结果。

Notice that "main.main" is a niladic function with no return type.
It's defined that way.  Falling off the end of "main.main" means
''success''; if you want to signal an erroneous return, call

值得注意的地方是"main.main"函数并没有返回值（函数被定义为没有返回值的类型）。如果"main.main"
运行到了末尾，就表示“成功”。如果想返回一个出错信息，可用系统调用强制退出：

	os.Exit(1)

The "os" package contains other essentials for getting
started; for instance, "os.Args" is a slice used by the
"flag" package to access the command-line arguments.

"os"包还包含了其它的许多启动相关的功能，例如"os.Args"是"flag"包的一部分（用来获取命令行输入）。

An Interlude about Types 类型简介
----

Go has some familiar types such as "int" and "float", which represent
values of the ''appropriate'' size for the machine. It also defines
explicitly-sized types such as "int8", "float64", and so on, plus
unsigned integer types such as "uint", "uint32", etc.  These are
distinct types; even if "int" and "int32" are both 32 bits in size,
they are not the same type.  There is also a "byte" synonym for
"uint8", which is the element type for strings.

Go语言中有一些通用的类型，例如"int"和"float"，它们对应的内存大小和处理器类型相关。同时，
也包含了许多固定大小的类型，例如"int8"和"float64"，还有无符号类型"uint"和"uint32"等。
需要注意的是，即使"int"和"int32"占有同样的内存大小，但并不是同一种数据类型。不过
"byte"和"uint8"对应是相同的数据类型，它们是字符串中字符类型。

Speaking of "string", that's a built-in type as well.  Strings are
<i>immutable values</i>&mdash;they are not just arrays of "byte" values.
Once you've built a string <i>value</i>, you can't change it, although
of course you can change a string <i>variable</i> simply by
reassigning it.  This snippet from "strings.go" is legal code:

go中的字符串是一个内建数据类型。字符串虽然是字符序列，但并不是一个字符数组。可以创建新的
字符串，但是不能改变字符串。不过我们可以通过新的字符串来达到想改变字符串的目的。
下面列举"strings.go"例子说明字符串的常见用法：

--PROG progs/strings.go /hello/ /ciao/

However the following statements are illegal because they would modify
a "string" value:

不管如何，试图修改字符串的做法都是被禁止的：

	s[0] = 'x';
	(*p)[1] = 'y';

In C++ terms, Go strings are a bit like "const strings", while pointers
to strings are analogous to "const string" references.

Go中的字符串和C++中的"const strings"概念类似，字符串指针则相当于C++中的"const strings"
引用。

Yes, there are pointers.  However, Go simplifies their use a little;
read on.

是的，它们都是指针，但是Go中用法更简单一些。

Arrays are declared like this:

数组的声明如下：

	var arrayOfInt [10]int;

Arrays, like strings, are values, but they are mutable. This differs
from C, in which "arrayOfInt" would be usable as a pointer to "int".
In Go, since arrays are values, it's meaningful (and useful) to talk
about pointers to arrays.

数组和字符串一样也是一个值对象，不过数组的元素是可以修改的。不同于C语言的是："int"类型数组
"arrayOfInt"并不能转化为"int"指针。因为，在Go语言中数组是一个值对象，它在内部保存"int"指针。

The size of the array is part of its type; however, one can declare
a <i>slice</i> variable, to which one can assign a pointer to
any array
with the same element type or&mdash;much more commonly&mdash;a <i>slice
expression</i> of the form "a[low : high]", representing
the subarray indexed by "low" through "high-1".
Slices look a lot like arrays but have
no explicit size ("[]" vs. "[10]") and they reference a segment of
an underlying, often anonymous, regular array.  Multiple slices
can share data if they represent pieces of the same array;
multiple arrays can never share data.

数组的大小是数组类型的一部分。我们还可以通过<i>slice（切片）</i>类型的变量来访问数组。
首先，数据元素的类型要和<i>slice（切片）</i>类型相同，然后通过"a[low : high]"类似的
语法来关联数组的low到heigh-1的子区间元素。Slices和数组的声明语法类似，但是不像数组那样
要指定元素的个数（"[]"和"[10]"的区别）；它在内部引用特定的空间，或者其它数组的空间。
如果多个Slices引用同一个数组，则可以共享数组的空间。但是不同数组之间是无法共享内存空间的。

Slices are much more common in Go programs than
regular arrays; they're more flexible, have reference semantics,
and are efficient.  What they lack is the precise control of storage
layout of a regular array; if you want to have a hundred elements
of an array stored within your structure, you should use a regular
array.

在Go语言中Slices比数组使用的更为普遍，因为它更有弹性，引用的语法也使得它效率很高。
但是，Slices缺少对内存的绝对控制比数组要差一些。例如你只是想要一个可以存放100个元素
的空间，那么你就可以选择数组了。

When passing an array to a function, you almost always want
to declare the formal parameter to be a slice.  When you call
the function, take the address of the array and  Go will
create (efficiently) a slice reference and pass that.

当需要传递一个数组给函数时，你应该将函数的参数定义为一个Slice。这样，在调用函数的时候，
数组将被自动转换为slice传入。

Using slices one can write this function (from "sum.go"):

使用slices可以写出以下函数（来自"sum.go"）：

--PROG progs/sum.go /sum/ /^}/

and invoke it like this:

可以这样调用：

--PROG progs/sum.go /1,2,3/

Note how the return type ("int") is defined for "sum()" by stating it
after the parameter list.
The expression "[3]int{1,2,3}"&mdash;a type followed by a
brace-bounded
expression&mdash;is a constructor for a value, in this case an array
of 3 "ints".
Putting an "&amp;"
in front gives us the address of a unique instance of the value.  We pass the
pointer to "sum()" by (implicitly) promoting it to a slice.

函数的返回值类型在参数列表后定义。表达式"[3]int{1,2,3}"定义一个含有3个"int"类型元素的数组
（并且已经初始化），然后用"&amp;"来获取数组的地址。我们用数组指针作为参数调用"sum()"，数组
指针被自动转换为slice类型。

If you are creating a regular array but want the compiler to count the
elements for you, use "..." as the array size:

如果你创建一个初始化的数组，你可以倚赖编译起计算数组的元素数目，只要在数组大小中填写"..."就
可以了：

	s := sum(&amp;[...]int{1,2,3});

In practice, though, unless you're meticulous about storage layout within a
data structure, a slice itself&mdash;using empty brackets and no
"&amp;"&mdash;is all you need:

在编码时，除非需要精确控制内存布局；简单的方式是用slice（数组大小为空）作为参数，并且不需要
取数组的地址。

	s := sum([]int{1,2,3});

There are also maps, which you can initialize like this:

还有map类型，可以用以下代码初始化：

	m := map[string]int{"one":1 , "two":2}

The built-in function "len()", which returns number of elements,
makes its first appearance in "sum".  It works on strings, arrays,
slices, maps, and channels.

用内建的"len()"函数，可以获取元素的数目，该函数在前面的"sum"中用到过。"len()"函数
还可以用在strings, arrays, slices, maps, 和 channels 中。

By the way, another thing that works on strings, arrays, slices, maps
and channels is the "range" clause on "for" loops.  Instead of writing

还有另外"range"方法可以用到strings, arrays, slices, maps, 和 channels 中，
它可以用于"for"循环的迭代。以下代码

	for i := 0; i &lt; len(a); i++ { ... }

to loop over the elements of a slice (or map or ...) , we could write

也可以写成：

	for i, v := range a { ... }

This assigns "i" to the index and "v" to the value of the successive
elements of the target of the range.   See
<a href='/doc/effective_go.html'>Effective Go</a>
for more examples of its use.

这里的"i"对应元素的索引，"v"对应元素的值。关于更多的细节可以参考
<a href='/doc/effective_go.html'>Effective Go</a>。

An Interlude about Allocation
----

Most types in Go are values. If you have an "int" or a "struct"
or an array, assignment
copies the contents of the object.
To allocate a new variable, use "new()", which
returns a pointer to the allocated storage.
在Go语言中，大部分的类型都是变量。如果你有个int或struct(结构体)或
array(数组)的变量，你需要拷贝他们的内容到一个新对象中，并重新分配一个
新的变量，就用new(), 它的返回值是一个指向被分配地址空间的指针。

	type T struct { a, b int }
	var t *T = new(T);

or the more idiomatic
或者用别的方法

	t := new(T);

Some types&mdash;maps, slices, and channels (see below)&mdash;have reference semantics.
If you're holding a slice or a map and you modify its contents, other variables
referencing the same underlying data will see the modification.  For these three
types you want to use the built-in function "make()":
有一些类型，如: maps, slices 和 channels(见下面)有reference semantics(引用语意).
如果你修改了slice 或 map相关的内容，其他引用了这些数据的变量也能看到这个改变。对于
这三个类型你得使用另一个内建的函数make()

	m := make(map[string]int);

This statement initializes a new map ready to store entries.
If you just declare the map, as in
上面的语句初始化一个新的map并分配了存储空间
如果你只想声明一个map，代码如下:

	var m map[string]int;

it creates a "nil" reference that cannot hold anything. To use the map,
you must first initialize the reference using "make()" or by assignment from an
existing map.
它创建了一个nil(空的)引用并且没有分配存储空间。如果你想用这个map, 你必须使用make来
初始化引用或者指向一个已经存在的map。

Note that "new(T)" returns type "*T" while "make(T)" returns type
"T".  If you (mistakenly) allocate a reference object with "new()",
you receive a pointer to a nil reference, equivalent to
declaring an uninitialized variable and taking its address.
注意: new(T)返回的类型是*T, 而make(T)返回的是T. 如果你(错误的)使用new()分配
了一个引用对象，你将会得到一个指向nil引用的指针。这个相当于声明了一个未初始化
的变量并取得它的地址.

An Interlude about Constants
----

Although integers come in lots of sizes in Go, integer constants do not.
There are no constants like "0LL" or "0x0UL".   Instead, integer
constants are evaluated as large-precision values that
can overflow only when they are assigned to an integer variable with
too little precision to represent the value.
虽然在Go中整数(integer)占用了大量的空间，但是常量类型的整数并没有占用很多空间。
这里没有像0LL 或 0x0UL的常量，取而代之的是，使用整数常量作为大型高精度的值，只有当
他们被重新定义给另一个变量的时候才能超载.

	const hardEight = (1 &lt;&lt; 100) &gt;&gt; 97  // legal

There are nuances that deserve redirection to the legalese of the
language specification but here are some illustrative examples:
这里重新定义和语言规范还是有些差别，下面是说明和规则:

	var a uint64 = 0  // a has type uint64, value 0
	a := uint64(0)    // equivalent; uses a "conversion"
	i := 0x1234       // i gets default type: int
	var j int = 1e6   // legal - 1000000 is representable in an int
	x := 1.5          // a float
	i3div2 := 3/2     // integer division - result is 1
	f3div2 := 3./2.   // floating point division - result is 1.5

Conversions only work for simple cases such as converting "ints" of one
sign or size to another, and between "ints" and "floats", plus a few other
simple cases.  There are no automatic numeric conversions of any kind in Go,
other than that of making constants have concrete size and type when
assigned to a variable.
转换只能简单的使用，比如: 转换整数(int)到去其他的精度和大小，整数(int)与
浮点数(float), 还有其他一些简单类型。Go 里面没有任何自动数值转换，除了此处以为
由常数建立的变量是需要确定大小和类型.

An I/O Package
----

Next we'll look at a simple package for doing file I/O with the usual
sort of open/close/read/write interface.  Here's the start of "file.go":
接下来我们使用一个简单的包(package)来对文件(file)输入输出接口来操作: open/
close/read/write. 让我们从file.go开始:

--PROG progs/file.go /package/ /^}/

The first few lines declare the name of the
package&mdash;"file"&mdash;and then import two packages.  The "os"
package hides the differences
between various operating systems to give a consistent view of files and
so on; here we're going to use its error handling utilities
and reproduce the rudiments of its file I/O.
在开始的己行里声明了一个&mdash;"file"&mdash;包, 还导入(import)了其他两个包os和syscall.
os这个包封装了不同操作系统底层的实现，保留了统一的file(文件)和其他一些接口。在这里我们将
会用error handling utilities(错误管理)和从新实现基本的file I/O(文件输入输出)

The other item is the low-level, external "syscall" package, which provides
a primitive interface to the underlying operating system's calls.
还有其他一些比较底层的包(package), 如: syscall 包，它提供一些底层的系统调用(system's calls).

Next is a type definition: the "type" keyword introduces a type declaration,
in this case a data structure called "File".
To make things a little more interesting, our "File" includes the name of the file
that the file descriptor refers to.
接下来是一个类型(type)定义: 用"type"这个关键字来声明一个类型. 在这个例子里数据结构(data structure)
叫"File". 为了让这事变的有趣些，我们的File包含了一个这个文件的名字(name)用来描述这个文件。

Because "File" starts with a capital letter, the type is available outside the package,
that is, by users of the package.   In Go the rule about visibility of information is
simple: if a name (of a top-level type, function, method, constant or variable, or of
a structure field or method) is capitalized, users of the package may see it. Otherwise, the
name and hence the thing being named is visible only inside the package in which
it is declared.  This is more than a convention; the rule is enforced by the compiler.
In Go, the term for publicly visible names is ''exported''.
因为"File"结构体中的首字母是大写，所以这个类型包(package)外部访问. 在GO中访问规则的处理
是非常简单的: 如果名字(of a top-level type, function, method, constant or variable, or of
a structure field or method)是大写，那么引用了这个包(package)的使用者就可以访问到它。不然
名称和被命名的东西将只能有package内部看到。Go的这个规则比语言的规则要强硬，因为这个规则是由
编译器(compiler)强制规范的。在GO中，一组公开可见的名称是"exported".

In the case of "File", all its fields are lower case and so invisible to users, but we
will soon give it some exported, upper-case methods.
在这个File例子中, 所有的字段(fields)都是小写所以访问者看不到，但是我们将给它一个出口(exported),
一个大写的methods.

First, though, here is a factory to create a "File":
开始先创建一个File.

--PROG progs/file.go /newFile/ /^}/

This returns a pointer to a new "File" structure with the file descriptor and name
filled in.  This code uses Go's notion of a ''composite literal'', analogous to
the ones used to build maps and arrays, to construct a new heap-allocated
object.  We could write
这将返回一个指向新File结构体的指针并有文件描述和文件名. 这段代码使用了GO的''复合变量''(composite 
literal)的概念，就想创建一个maps 和arrays一样。要创建一个新的heap-allocated对象，我们将会写成

	n := new(File);
	n.fd = fd;
	n.name = name;
	return n

but for simple structures like "File" it's easier to return the address of a nonce
composite literal, as is done here on line 21.
但像File这样简单的结构体有更简单的方法让它返回一个复合变量(composite literal)的地址,
就像上个例子里面的21行。

We can use the factory to construct some familiar, exported variables of type "*File":
我们可以创建一个相似的结构，输出类型为*File的变量。

--PROG progs/file.go /var/ /^.$/

The "newFile" function was not exported because it's internal. The proper,
exported factory to use is "Open":
newFile这个函数没有输出(exported)是因为它是内部(internal)的. 真正的输出(exported)是
Open这个函数.

--PROG progs/file.go /func.Open/ /^}/

There are a number of new things in these few lines.  First, "Open" returns
multiple values, a "File" and an error (more about errors in a moment).
We declare the
multi-value return as a parenthesized list of declarations; syntactically
they look just like a second parameter list.  The function
"syscall.Open"
also has a multi-value return, which we can grab with the multi-variable
declaration on line 31; it declares "r" and "e" to hold the two values,
both of type "int" (although you'd have to look at the "syscall" package
to see that).  Finally, line 35 returns two values: a pointer to the new "File"
and the error.  If "syscall.Open" fails, the file descriptor "r" will
be negative and "newFile" will return "nil".
在这几行里出现了一些新的东西。首先，Open 返回多个变量值(multi-value)，一个File指针和一个error(
等一下会介绍errors). 我们用括号类表来声明返回多个变量值(multi-value). 语法上它看
起来像第二个参数列表。syscall.Open 这个函数同样也是返回multi-value, 接着我们能在31行
的声明取得这个multi-value的返回值。它创建了r和e两个变量，这两个都是int类型(你必须去syscall的package
里面才能看出来是个int类型)。最后，35行返回两个变量，一个指向File指针和一个error.
如果syscall.Open打开失败， 这个文件描述r将会是个负值，newFile将会返回nil.

About those errors:  The "os" library includes a general notion of an error.
It's a good idea to use its facility in your own interfaces, as we do here, for
consistent error handling throughout Go code.   In "Open" we use a
conversion to translate Unix's integer "errno" value into the integer type
"os.Errno", which implements "os.Error".
关于这个错误(errors): os这个函数包含了一些错误的感念. 在你的接口中使用它是个不错
的主意。就像我们在这里做的一样, 在GO里面统一管理错误处理。在Open这个函数中，我们
采用了Unix的整数错误代码os.Errno，并用它来实现os.Error.

Now that we can build "Files", we can write methods for them. To declare
a method of a type, we define a function to have an explicit receiver
of that type, placed
in parentheses before the function name. Here are some methods for "*File",
each of which declares a receiver variable "file".
现在我们可以创建Files, 我们为它写了些方法(methods). 要声明一个方法(method)类型,
我们定义了一个函数去指定它的类型，把它方在函数名之前的括号里。这里为*File创建了
一些方法(method), 每个都声明了可接受文件变量.

--PROG progs/file.go /Close/ END

There is no implicit "this" and the receiver variable must be used to access
members of the structure.  Methods are not declared within
the "struct" declaration itself.  The "struct" declaration defines only data members.
In fact, methods can be created for almost any type you name, such as an integer or
array, not just for "structs".   We'll see an example with arrays later.
这里没有使用this还有接受变量必须要访问结构体的成员。方法(methods)中并没有声明自己的结构体。
struct结构只声明数据成员(data members). 事实上，这些方法(methods)能被创建在任何你能说出来
的类型。如: 整数(integer), 数组(array), 并不仅仅只有结构体(structs). 我们待会就能看到数组
(array)的例子。


The "String" method is so called because of a printing convention we'll
describe later.
String这个方法之所以会被调用是为了更好的打印信息。我们待会才会说明。

The methods use the public variable "os.EINVAL" to return the ("os.Error"
version of the) Unix error code "EINVAL".  The "os" library defines a standard
set of such error values.
这个方法(methods)使用共有的变量os.EINVAL去返回(os.Error的版本)Unix错误代码EINVAL.
os函数库中定义了标准的error变量。

We can now use our new package:
现在我们可以使用我们自己创建的包(package)了.

--PROG progs/helloworld3.go /package/ END

The ''"./"'' in the import of ''"./file"'' tells the compiler to use our own package rather than
something from the directory of installed packages.
这个''"./"''在导入(import)''"./file"''时告诉编译器(compiler)使用我们自己的package, 而不是在
默认安装的package中找。

Finally we can run the program:
最后，我们来执行这个程序:

	% helloworld3
	hello, world
	can't open file; err=No such file or directory
	%

Rotting cats
----

Building on the "file" package, here's a simple version of the Unix utility "cat(1)",
"progs/cat.go":
在我们上面创建的file包(package)基础之上，实现一个简单的Unix工具 "cat(1)", "progs/cat.go":


--PROG progs/cat.go /package/ END

By now this should be easy to follow, but the "switch" statement introduces some
new features.  Like a "for" loop, an "if" or "switch" can include an
initialization statement.  The "switch" on line 18 uses one to create variables
"nr" and "er" to hold the return values from "f.Read()".  (The "if" on line 25
has the same idea.)  The "switch" statement is general: it evaluates the cases
from  top to bottom looking for the first case that matches the value; the
case expressions don't need to be constants or even integers, as long as
they all have the same type.
现在应该很容易被理解，但是还有些新的语法"switch". 比如: 包括了"for"循环， "if"和
"switch"初始化的语句。在"switch"语句的18行用了"f.Read()"函数的返回值"nr"和"er"做为
变量(25行中的"if"也采用同样的方法)。这里的"switch"语法和其他语言语法基本相同，每个分支(cases)
从上到下查找是否与相关的表达式相同，分支(case)的表达式不仅仅是常量(constants)或整数(integers),
它可以是你想到的任意类型。

Since the "switch" value is just "true", we could leave it off&mdash;as is also
the situation
in a "for" statement, a missing value means "true".  In fact, such a "switch"
is a form of "if-else" chain. While we're here, it should be mentioned that in
"switch" statements each "case" has an implicit "break".
这个"switch"的值永远是"真(true)", 我们会一直执行它, 就像"for"语句，不写值默认是"真"(true).
事实上，"switch"是从"if-else"由来的。在这里我们要说明, "switch"语句中的每个"分支"(case)都
默认隐藏了"break".

Line 25 calls "Write()" by slicing the incoming buffer, which is itself a slice.
Slices provide the standard Go way to handle I/O buffers.
在25行中调用"Write()"采用了slicing来取得buffer数据. 在标准的GO中提供了Slices对I/O buffers的操作。

Now let's make a variant of "cat" that optionally does "rot13" on its input.
It's easy to do by just processing the bytes, but instead we will exploit
Go's notion of an <i>interface</i>.
现在让我们做一个"cat"的升级版让"rot13"来处理输入, 就是个简单的字符处理，但是要
采用GO的新特性<i>"接口(interface)"</i>来实现。

The "cat()" subroutine uses only two methods of "f": "Read()" and "String()",
so let's start by defining an interface that has exactly those two methods.
Here is code from "progs/cat_rot13.go":
这个"cat()"使用了2个子程序"f":"Read()"和"String", 让我们定义这2个接口，
源码参考 "progs/cat_rot13.go"

--PROG progs/cat_rot13.go /type.reader/ /^}/

Any type that has the two methods of "reader"&mdash;regardless of whatever
other methods the type may also have&mdash;is said to <i>implement</i> the
interface.  Since "file.File" implements these methods, it implements the
"reader" interface.  We could tweak the "cat" subroutine to accept a "reader"
instead of a "*file.File" and it would work just fine, but let's embellish a little
first by writing a second type that implements "reader", one that wraps an
existing "reader" and does "rot13" on the data. To do this, we just define
the type and implement the methods and with no other bookkeeping,
we have a second implementation of the "reader" interface.
任何类型的方法都有"reader"这两个方法 &mdash; 也就是说实现了这两个方法，
任何类型的方法都能使用。由于"file.File"实现了"reader"接口，我们就可以让"cat"
的子程序访问"reader"从而取代了"*file.File"并且能正常工作，让我们来些第二个类型实现
"reader", 一个关注现有的"reader"，另一个"rot13"只关注数据。我们只是定义了这个类型和
实现了这个方法并没有做其他的内部处理, 我们实现了第二个"reader"接口.

--PROG progs/cat_rot13.go /type.rotate13/ /end.of.rotate13/

(The "rot13" function called on line 42 is trivial and not worth reproducing here.)
(42行的"rot13"函数非常简单，没有必要在这里进行讨论)

To use the new feature, we define a flag:
为了使用新的特性，我们定义了一个标记(flag):

--PROG progs/cat_rot13.go /rot13Flag/

and use it from within a mostly unchanged "cat()" function:
用它基本上不需要修改"cat()"这个函数:

--PROG progs/cat_rot13.go /func.cat/ /^}/

(We could also do the wrapping in "main" and leave "cat()" mostly alone, except
for changing the type of the argument; consider that an exercise.)
Lines 56 through 58 set it all up: If the "rot13" flag is true, wrap the "reader"
we received into a "rotate13" and proceed.  Note that the interface variables
are values, not pointers: the argument is of type "reader", not "*reader",
even though under the covers it holds a pointer to a "struct".
(我们应该对"main"和"cat"单独做些封装，不仅仅是对类型参数的修改，就当是练习)从56行到
58行: 如果"rot13"标记是真，封装的"reader"就会接受数据并传给"rotate13"并处理. 注意:
这个接口的值是变量，不是指针，这个参数是"reader"类型，不是"*reader", 尽管后面转换为
指向结构体的指针。

Here it is in action:
这里是执行结果:

<pre>
	% echo abcdefghijklmnopqrstuvwxyz | ./cat
	abcdefghijklmnopqrstuvwxyz
	% echo abcdefghijklmnopqrstuvwxyz | ./cat --rot13
	nopqrstuvwxyzabcdefghijklm
	%
</pre>

Fans of dependency injection may take cheer from how easily interfaces
allow us to substitute the implementation of a file descriptor.
也许你会说使用注入依赖(dependency injection)能轻松的让接口以一个文件描述符执行。

Interfaces are a distinctive feature of Go.  An interface is implemented by a
type if the type implements all the methods declared in the interface.
This means
that a type may implement an arbitrary number of different interfaces.
There is no type hierarchy; things can be much more <i>ad hoc</i>,
as we saw with "rot13".  The type "file.File" implements "reader"; it could also
implement a "writer", or any other interface built from its methods that
fits the current situation. Consider the <i>empty interface</i>
接口(interfaces)是Go的一个特性，一个接口是由类型实现的，接口就是声明该类型的所有方法。
也就是说一个类型可以实现多个不同的接口, 没有任何类型的限制，就像我们的例子"rot13".
"file.File"这个类型实现了"reader", 它也能实现"writer", 或通过其他的方法来实现这个接口。
参考<i>空接口(empty interface)</i>

<pre>
	type Empty interface {}
</pre>

<i>Every</i> type implements the empty interface, which makes it
useful for things like containers.
任何类型都默认实现了空接口，我们可以用空接口来保存任意类型。

Sorting
----

Interfaces provide a simple form of polymorphism.  They completely
separate the definition of what an object does from how it does it, allowing
distinct implementations to be represented at different times by the
same interface variable.
接口(interfaces)提供了一个简单形式的多态(polymorphism). 他们把对象的定义和
如何实现的分开处理，允许相同的接口可以有不能的实现方法。

As an example, consider this simple sort algorithm taken from "progs/sort.go":
参考这个简单的排序算法(sort algorithm)"progs/sort.go"

--PROG progs/sort.go /func.Sort/ /^}/

The code needs only three methods, which we wrap into sort's "Interface":
我们要封装这个排序(sort)的接口(interface)仅需要三个方法。

--PROG progs/sort.go /interface/ /^}/

We can apply "Sort" to any type that implements "Len", "Less", and "Swap".
The "sort" package includes the necessary methods to allow sorting of
arrays of integers, strings, etc.; here's the code for arrays of "int"
我们可以用任何类型的"Sort"去实现"Len", "Less" 和 "Swap". 这个"sort"包里面
包含一些方法(methods). 下面是整型数组的代码: 

--PROG progs/sort.go /type.*IntArray/ /Swap/

Here we see methods defined for non-"struct" types.  You can define methods
for any type you define and name in your package.
你看到的是一个没有任何类型的"结构体"(non-struct type). 在你的包里面你可以定义
任何你想定义的类型.

And now a routine to test it out, from "progs/sortmain.go".  This
uses a function in the "sort" package, omitted here for brevity,
to test that the result is sorted.
现在用"progs/sortmain.go"程序进行测试，用"sort"包里面的排序函数进行排序。

--PROG progs/sortmain.go /func.ints/ /^}/

If we have a new type we want to be able to sort, all we need to do is
to implement the three methods for that type, like this:
如果我们为sort提供一个新类型，我们就需要为这个类型实现三个方法，如下:

--PROG progs/sortmain.go /type.day/ /Swap/


Printing 打印
----

The examples of formatted printing so far have been modest.  In this section
we'll talk about how formatted I/O can be done well in Go.

前面例子中涉及到的打印都比较简单。在这一节中，我们将要讨论Go语言格式化输出的功能。

We've seen simple uses of the package "fmt", which
implements "Printf", "Fprintf", and so on.
Within the "fmt" package, "Printf" is declared with this signature:

我们已经用过"fmt"包中的"Printf"和"Fprintf"等输出函数。"fmt"包中的"Printf"函数的
完整说明如下：

	Printf(format string, v ...) (n int, errno os.Error)

That "..." represents the variadic argument list that in C would
be handled using the "stdarg.h" macros but in Go is passed using
an empty interface variable ("interface {}") and then unpacked
using the reflection library.  It's off topic here but the use of
reflection helps explain some of the nice properties of Go's "Printf",
due to the ability of "Printf" to discover the type of its arguments
dynamically.

其中"..."表示数目可变参数，和C语言中"stdarg.h"中的宏类似。不过Go中，可变参数是通道
一个空接口（"interface {}"）和反射（reflection）库实现的。反射特性可以帮助"Printf"
函数很好的获取参数的详细特征。

For example, in C each format must correspond to the type of its
argument.  It's easier in many cases in Go.  Instead of "%llud" you
can just say "%d"; "Printf" knows the size and signedness of the
integer and can do the right thing for you.  The snippet

在C语言中，printf函数的要格式化的参数类型必须和格式化字符串中的标志一致。不过在Go语言中，
这些细节都被简化了。我们不再需要"%llud"之类的标志，只用"%d"表示要输出一个整数。至于对应
参数的实际类型，"Printf"可以通过反射获取。例如：

--PROG progs/print.go 'NR==10' 'NR==11'

prints

	18446744073709551615 -1

In fact, if you're lazy the format "%v" will print, in a simple
appropriate style, any value, even an array or structure.  The output of

最简单的方法是用"%v"标志，它可以以适当的格式输出任意的类型（包括数组和结构）。下面的程序，

--PROG progs/print.go 'NR==14' 'NR==20'

is 将输出：

	18446744073709551615 {77 Sunset Strip} [1 2 3 4]

You can drop the formatting altogether if you use "Print" or "Println"
instead of "Printf".  Those routines do fully automatic formatting.
The "Print" function just prints its elements out using the equivalent
of "%v" while "Println" inserts spaces between arguments
and adds a newline.  The output of each of these two lines is identical
to that of the "Printf" call above.

如果是使用"Print"或"Println"函数的话，甚至不需要格式化字符串。这些函数会针对数据类型
自动作转换。"Print"函数默认将每个参数以"%v"格式输出，"Println"函数则是在"Print"函数
的输出基础上增加一个换行。一下两种输出方式和前面的输出结果是一致的。

--PROG progs/print.go 'NR==21' 'NR==22'

If you have your own type you'd like "Printf" or "Print" to format,
just give it a "String()" method that returns a string.  The print
routines will examine the value to inquire whether it implements
the method and if so, use it rather than some other formatting.
Here's a simple example.

如果要用"Printf"或"Print"函数输出似有的结构类型，之需要为该结构实现一个"String()"方法，
返回相应的字符串就可以了。打印函数会先检测该类型是否实现了"String()"方法，如果实现了则以
该方法返回字符串作为输出。下面是一个简单的例子。

--PROG progs/print_string.go 'NR==9' END

Since "*testType" has a "String()" method, the
default formatter for that type will use it and produce the output

因为"*testType"类型有"String()"方法，因此格式化函数用它作为输出结果：

	77 Sunset Strip

Observe that the "String()" method calls "Sprint" (the obvious Go
variant that returns a string) to do its formatting; special formatters
can use the "fmt" library recursively.

前面的例子中，"String()"方法用到了"Sprint"（从字面意思可以猜测函数将返回一个字符串）
作为格式化的基础函数。在Go中，我们可以递归使用"fmt"库中的函数来为格式化服务。

Another feature of "Printf" is that the format "%T" will print a string
representation of the type of a value, which can be handy when debugging
polymorphic code.

"Printf"函数的另一种输出是"%T"格式，它输出的内容更加详细，可以作为调试信息用。

It's possible to write full custom print formats with flags and precisions
and such, but that's getting a little off the main thread so we'll leave it
as an exploration exercise.

自己实现一个功能完备，可以输出各种格式和精度的函数是可能的。不过这不是该教程的重点，大家
可以把它当作一个课后练习。

You might ask, though, how "Printf" can tell whether a type implements
the "String()" method.  Actually what it does is ask if the value can
be converted to an interface variable that implements the method.
Schematically, given a value "v", it does this:

读者可能有疑问，"Printf"函数是如何知道变量是否有"String()"函数实现的。实际上，我们
需要先将变量转换为Stringer接口类型，如果转换成功则表示有"String()"方法。下面是一个
演示的例子：


	type Stringer interface {
		String() string
	}

	s, ok := v.(Stringer);  // Test whether v implements "String()"
	if ok {
		result = s.String()
	} else {
		result = defaultOutput(v)
	}

The code uses a ``type assertion'' ("v.(Stringer)") to test if the value stored in
"v" satisfies the "Stringer" interface; if it does, "s"
will become an interface variable implementing the method and "ok" will
be "true".  We then use the interface variable to call the method.
(The ''comma, ok'' pattern is a Go idiom used to test the success of
operations such as type conversion, map update, communications, and so on,
although this is the only appearance in this tutorial.)
If the value does not satisfy the interface, "ok" will be false.

这里用到了类型断言("v.(Stringer)")，用来判断变量"v"是否可以满足"Stringer"接口。
如果满足，"s"将对应转换后的Stringer接口类型并且"ok"被设置为"true"。然后我们通过"s"，
以Stringer接口的方式调用String()函数。如果不满足该接口特征，"ok"将被设置为false。

In this snippet the name "Stringer" follows the convention that we add ''[e]r''
to interfaces describing simple method sets like this.

"Stringer"接口的命名通常是在接口方法的名字后面加''[e]r''后缀，这里是"String+er"。

One last wrinkle.  To complete the suite, besides "Printf" etc. and "Sprintf"
etc., there are also "Fprintf" etc.  Unlike in C, "Fprintf"'s first argument is
not a file.  Instead, it is a variable of type "io.Writer", which is an
interface type defined in the "io" library:

Go中的打印函数，除了"Printf"和"Sprintf"等之外，还有一个"Fprintf"函数。不过"Fprintf"函数和
的第一个参数并不是一个文件，而是一个在"io"库中定义的接口类型：

	type Writer interface {
		Write(p []byte) (n int, err os.Error);
	}

(This interface is another conventional name, this time for "Write"; there are also
"io.Reader", "io.ReadWriter", and so on.)
Thus you can call "Fprintf" on any type that implements a standard "Write()"
method, not just files but also network channels, buffers, whatever
you want.

这里的接口也是采用类似的命名习惯，类型的接口还有"io.Reader"和"io.ReadWriter"等。
在调用"Fprintf"函数时，可以用实现了"Write"方法的任意类型变量作为参数，例如文件、网络、管道等等。

Prime numbers 生成素数
----

Now we come to processes and communication&mdash;concurrent programming.
It's a big subject so to be brief we assume some familiarity with the topic.

这里我们要给出一个并行处理程序及之间的通信。这是一个非常大的课题，我们这里只是给出一些要点。

A classic program in the style is a prime sieve.
(The sieve of Eratosthenes is computationally more efficient than
the algorithm presented here, but we are more interested in concurrency than
algorithmics at the moment.)
It works by taking a stream of all the natural numbers and introducing
a sequence of filters, one for each prime, to winnow the multiples of
that prime.  At each step we have a sequence of filters of the primes
so far, and the next number to pop out is the next prime, which triggers
the creation of the next filter in the chain.

素数筛选是一个比较经典的问题（这里侧重于Eratosthenes素数筛选算法的并行特征）。它以全部的
自然后为筛选对象。首选从第一个素数2开始，后续数列中是已经素数倍数的数去掉。每次筛选可以得到
一个新的素数，然后将新的素数加入筛选器，继续筛选后面的自然数列（这里要参考算法的描述调整）。

Here's a flow diagram; each box represents a filter element whose
creation is triggered by the first number that flowed from the
elements before it.

这里是算法工作的原理图。每个框对应一个素数筛选器，并且将剩下的数列传给下一个素数筛进行筛选。

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src='sieve.gif'>

<br>

To create a stream of integers, we use a Go <i>channel</i>, which,
borrowing from CSP's descendants, represents a communications
channel that can connect two concurrent computations.
In Go, channel variables are references to a run-time object that
coordinates the communication; as with maps and slices, use
"make" to create a new channel.

为了产生整数序列，我们使用<i>管道</i>。管道可以用于连接两个并行的处理单。在Go语言中，
管道由运行时库管理，可以用"make"来创建新的管道。

Here is the first function in "progs/sieve.go":

这是"progs/sieve.go"程序的第一个函数：

09    // Send the sequence 2, 3, 4, ... to channel 'ch'.
10    func generate(ch chan int) {
11        for i := 2; ; i++ {
12            ch <- i  // Send 'i' to channel 'ch'.
13        }
14    }

--PROG progs/sieve.go /Send/ /^}/

The "generate" function sends the sequence 2, 3, 4, 5, ... to its
argument channel, "ch", using the binary communications operator "&lt;-".
Channel operations block, so if there's no recipient for the value on "ch",
the send operation will wait until one becomes available.

函数"generate"用于生成2, 3, 4, 5, ...自然数序列，然后依次发送到管道。
这里用到了二元操作符"&lt;-"， 它用于向管道发送数据。当管道没有接受者的时候
会阻塞，直到有接收者从管道接受数据为止。

The "filter" function has three arguments: an input channel, an output
channel, and a prime number.  It copies values from the input to the
output, discarding anything divisible by the prime.  The unary communications
operator "&lt;-" (receive) retrieves the next value on the channel.

过滤器函数有三个参数：输入输出管道和用于过滤的素数。当输入管道读出来的数不能被
过滤素数整除时，则将当前整数发送到输出管道。这里用到了"&lt;-"操作符，它用于从
管道读取数据。

16    // Copy the values from channel 'in' to channel 'out',
17    // removing those divisible by 'prime'.
18    func filter(in, out chan int, prime int) {
19        for {
20            i := <-in  // Receive value of new variable 'i' from 'in'.
21            if i % prime != 0 {
22                out <- i  // Send 'i' to channel 'out'.
23            }
24        }
25    }

--PROG progs/sieve.go /Copy.the/ /^}/

The generator and filters execute concurrently.  Go has
its own model of process/threads/light-weight processes/coroutines,
so to avoid notational confusion we call concurrently executing
computations in Go <i>goroutines</i>.  To start a goroutine,
invoke the function, prefixing the call with the keyword "go";
this starts the function running in parallel with the current
computation but in the same address space:

整数生成器generator函数和过滤器filters是并行执行的。Go语言有自己的并发
程序设计模型，这个和传统的进程/线程/轻量线程类似。为了区别，我们把Go语言
中的并行程序称为<i>goroutines</i>。如果一个函数要以goroutines方式并行执行，
只要用"go"关键字作为函数调用的前缀即可。goroutines和它的启动线程并行执行，
但是共享一个地址空间。例如，以goroutines方式执行前面的sum函数：

	go sum(hugeArray); // calculate sum in the background

If you want to know when the calculation is done, pass a channel
on which it can report back:

如果想知道计算什么时候结束，可以让sum用管道把结果返回：

	ch := make(chan int);
	go sum(hugeArray, ch);
	// ... do something else for a while
	result := &lt;-ch;  // wait for, and retrieve, result

Back to our prime sieve.  Here's how the sieve pipeline is stitched
together:

再回到我们的素数筛选程序。下面程序演示如何将不同的素数筛链接在一起：

28    func main() {
29        ch := make(chan int)  // Create a new channel.
30        go generate(ch)  // Start generate() as a goroutine.
31        for {
32            prime := <-ch
33            fmt.Println(prime)
34            ch1 := make(chan int)
35            go filter(ch, ch1, prime)
36            ch = ch1
37        }
38    }

--PROG progs/sieve.go /func.main/ /^}/

Line 29 creates the initial channel to pass to "generate", which it
then starts up.  As each prime pops out of the channel, a new "filter"
is added to the pipeline and <i>its</i> output becomes the new value
of "ch".

29行先调用"generate"函数，用于产生最原始的自然数序列（从2开始）。然后
从输出管道读取的第一个数为新的素数，并以这个新的素数生成一个新的过滤器。
然后将新创建的过滤器添加到前一个过滤器后面，新过滤器的输出作为新的输出
管道。

The sieve program can be tweaked to use a pattern common
in this style of programming.  Here is a variant version
of "generate", from "progs/sieve1.go":

sieve程序还可以写的更简洁一点。这里是"generate"的改进，代码在
"progs/sieve1.go"中：

10    func generate() chan int {
11        ch := make(chan int)
12        go func(){
13            for i := 2; ; i++ {
14                ch <- i
15            }
16        }()
17        return ch
18    }

--PROG progs/sieve1.go /func.generate/ /^}/

This version does all the setup internally. It creates the output
channel, launches a goroutine running a function literal, and
returns the channel to the caller.  It is a factory for concurrent
execution, starting the goroutine and returning its connection.

新完善的generate函数在内部进行必须的初始化操作。它创建输出管道，然后
启动goroutine用于产生整数序列，最后返回输出管道。它类似于一个并发程序
的工厂函数，完成后返回一个用于链接的管道。

The function literal notation (lines 12-16) allows us to construct an
anonymous function and invoke it on the spot. Notice that the local
variable "ch" is available to the function literal and lives on even
after "generate" returns.

第12-16行用go关键字启动一个匿名函数。需要注意的是，generate函数的"ch"
变量对于匿名函数是可见，并且"ch"变量在generate函数返回后依然存在（因为
匿名的goroutine还在运行）。

The same change can be made to "filter":

这里我们采用过滤器"filter"来筛选后面的素数：

21    func filter(in chan int, prime int) chan int {
22        out := make(chan int)
23        go func() {
24            for {
25                if i := <-in; i % prime != 0 {
26                    out <- i
27                }
28            }
29        }()
30        return out
31    }

--PROG progs/sieve1.go /func.filter/ /^}/

The "sieve" function's main loop becomes simpler and clearer as a
result, and while we're at it let's turn it into a factory too:

函数"sieve"对应处理的一个主循环，它只是依次将数列交给后面的素数筛选器进行筛选。
如果遇到新的素数，再输出素数后以该素数创建信的筛选器。

33    func sieve() chan int {
34        out := make(chan int)
35        go func() {
36            ch := generate()
37            for {
38                prime := <-ch
39                out <- prime
40                ch = filter(ch, prime)
41            }
42        }()
43        return out
44    }

--PROG progs/sieve1.go /func.sieve/ /^}/

Now "main"'s interface to the prime sieve is a channel of primes:

主函数入口启动素数生成服务器，然后打印从管道输出的素数：

46    func main() {
47        primes := sieve()
48        for {
49            fmt.Println(<-primes)
50        }
51    }

--PROG progs/sieve1.go /func.main/ /^}/

Multiplexing 多路复用
----

With channels, it's possible to serve multiple independent client goroutines without
writing an explicit multiplexer.  The trick is to send the server a channel in the message,
which it will then use to reply to the original sender.
A realistic client-server program is a lot of code, so here is a very simple substitute
to illustrate the idea.  It starts by defining a "request" type, which embeds a channel
that will be used for the reply.

基于管道，我们可以很容易实现一个支持多路客户端的服务器程序。采用的技巧是将每个客户端私有的通信管道
作为消息的一部分发送给服务器，然后服务器通过这些管道和客户端独立通信。现实中的服务器实现都很复杂，
我们这里只给出一个服务器的简单实现来展现前面描述的技巧。首先定义一个"request"类型，里面包含一个
客户端的通信管道。

--PROG progs/server.go /type.request/ /^}/

The server will be trivial: it will do simple binary operations on integers.  Here's the
code that invokes the operation and responds to the request:

服务器对客户端发送过来的两个整数进行运算。下面是具体的函数，函数在运算完之后将结构通过结构中的
管道返回给客户端。

--PROG progs/server.go /type.binOp/ /^}/

Line 14 defines the name "binOp" to be a function taking two integers and
returning a third.

第14行现定义一个"binOp"函数类型，用于对两个整数进行运算。

The "server" routine loops forever, receiving requests and, to avoid blocking due to
a long-running operation, starting a goroutine to do the actual work.

服务器routine线程是一个无限循环，它接受客户端请求。然后为每个客户端启动一个独立的routine线程，
用于处理客户数据（不会被某个客户端阻塞）。

--PROG progs/server.go /func.server/ /^}/

We construct a server in a familiar way, starting it and returning a channel
connected to it:

启动服务器的方法也是一个类似的routine线程，然后返回服务器的请求管道。

--PROG progs/server.go /func.startServer/ /^}/

Here's a simple test.  It starts a server with an addition operator and sends out
"N" requests without waiting for the replies.  Only after all the requests are sent
does it check the results.

这里是一个简单的测试。首先启动服务器，处理函数为计算两个整数的和。接着向服务器发送"N"个请求（无阻塞）。
当所有请求都发送完了之后，再进行验证返回结果。

--PROG progs/server.go /func.main/ /^}/

One annoyance with this program is that it doesn't shut down the server cleanly; when "main" returns
there are a number of lingering goroutines blocked on communication.  To solve this,
we can provide a second, "quit" channel to the server:

前面的服务器程序有个小问题：当main函数退出之后，服务器没有关闭，而且可能有一些客户端被阻塞在
管道通信中。为了处理这个问题，我们可给服务器增加一个控制管道，用于退出服务器。

--PROG progs/server1.go /func.startServer/ /^}/

It passes the quit channel to the "server" function, which uses it like this:

首先给"server"函数增加一个控制管道参数，然后这样使用：

--PROG progs/server1.go /func.server/ /^}/

Inside "server", the "select" statement chooses which of the multiple communications
listed by its cases can proceed.  If all are blocked, it waits until one can proceed; if
multiple can proceed, it chooses one at random.  In this instance, the "select" allows
the server to honor requests until it receives a quit message, at which point it
returns, terminating its execution.

在服务器函数中，"select"操作服用于从多个通讯管道中选择一个就绪的管道。如果所有的管道都没有数据，
那么将等待知道有任意一个管道有数据。如果有多个管道就绪，则随即选择一个。服务器处理客户端请求，如果
有退出消息则退出。

All that's left is to strobe the "quit" channel
at the end of main:

最后是在main函数中保存"quit"管道，然后在退出的时候向服务线程发送停止命令。

--PROG progs/server1.go /adder,.quit/
...
--PROG progs/server1.go /quit....true/

There's a lot more to Go programming and concurrent programming in general but this
quick tour should give you some of the basics.

当然，Go语言及并行编程要讨论的问题很多。这个入门只是给出一些简单的例子。


